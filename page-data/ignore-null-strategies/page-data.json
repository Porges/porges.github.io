{"componentChunkName":"component---src-templates-blog-post-js","path":"/ignore-null-strategies/","result":{"data":{"site":{"siteMetadata":{"title":"porg.es"}},"markdownRemark":{"id":"977a2690-ac0d-57ec-a649-6f479385795a","excerpt":"Thereâ€™s no such thing as a null strategy! Here is a simple refactoring/micro-pattern that can help remove a little complexity from classes that use passed-inâ€¦","html":"<blockquote>\n<p>Thereâ€™s no such thing as a null strategy!</p>\n</blockquote>\n<p>Here is a simple refactoring/micro-pattern that can help remove a little complexity from classes that use passed-in behaviours/strategies/handlers/whatever you want to call them. <sup id=\"fnref-n\"><a href=\"#fn-n\" class=\"footnote-ref\">n</a></sup>\nThe examples given here may seem rather abstract or â€œenterpriseyâ€, but itâ€™s something that comes up repeatedly when developing software.</p>\n<h3>The problem: Checking strategies for nullness</h3>\n<p>Below is a very simplified example of a consumer (the class <code class=\"language-text\">ProducerExample</code>) of the <code class=\"language-text\">IProducer</code> strategy. The consumer explicitly checks if the strategy is null before invoking it, and if it <em>is</em> null, it produces some default value instead.</p>\n<p>This extra null check gets in the way of what the class is actually doing and introduces an extra code path that is not wanted (or needed).</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=0-producer.cs\"></script>\n<p>(The producer here is deliberately simpleâ€”in a real codebase this could take any number of arguments.)</p>\n<p>One situation where this kind of code might appear is when a previously-untested class is being tested for the first time. In this case, dummy values might be inserted in order that <code class=\"language-text\">null</code> can be passed as the strategy at test time and youâ€™ll still get results instead of a <code class=\"language-text\">NullReferenceException</code>. This kind of setup is dangerous, as inadvertently passing <code class=\"language-text\">null</code> in the production code will end up generating these dummy values! ğŸ’¥</p>\n<p>Hereâ€™s a very similar example, using a strategy that doesnâ€™t have a result (which Iâ€™ll call a â€œhandlerâ€). This is checked for nullness before it is invoked for its side-effects:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=1-handler.cs\"></script>\n<h3>Solution: Donâ€™t check strategies for nullness!</h3>\n<p>Instead of explicitly checking for nullness, assume that the strategy is not null (you can enforce this in the constructor) and migrate any â€œdefault actionâ€ into a new implementation of the strategy.</p>\n<p>Then, anywhere you were previously passing in <code class=\"language-text\">null</code>, you can instead pass an instance of your shiny new implementation.</p>\n<p>For the producer example, we can move the default implementation into a new class, and remove the null check:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=2-producer2.cs\"></script>\n<p>(The <code class=\"language-text\">[NotNull]</code> annotation here is something supported by Resharper via the <a href=\"https://www.nuget.org/packages/JetBrains.Annotations\">Resharper.Annotations</a> package.)</p>\n<p>If we need to change the result of the producer depending on what the consumer is, we can use a variation on this, and create an implementation that stores any value we want:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=3-producer2-2.cs\"></script>\n<p>In the â€œhandlerâ€ case, we can create a <a href=\"https://en.wikipedia.org/wiki/Null_Object_pattern\">â€˜null objectâ€™ implementation</a> that does nothing, since we donâ€™t need to produce a result:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=4-handler2.cs\"></script>\n<p>With the refactored code, the consuming classes are cleaner (less code, lower cyclomatic complexity), and we have extracted a â€œdefaultâ€ implementation, which could potentially be used by other consumers.</p>\n<p>At the same time, we have created some useful additional implementations that we can use in unit tests! The â€œDefaultâ€ or â€œConstantâ€ producers are useful when providing canned data to classes that are being tested, and â€œNullâ€ handlers are useful when ignoring part of the behaviour of a class in order to test other parts.</p>\n<hr>\n<h4>Variation: Function-oriented implementation</h4>\n<p>For single-method interfaces such as those above we can replace them with delegates. This can lead to much cleaner code.</p>\n<p>For producers:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=5-producer-functional.cs\"></script>\n<p>And for handlers:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=6-handler-functional.cs\"></script>\n<p>I have yet to explore this style in-depth myself, but it seems promising. (I would avoid using pure <code class=\"language-text\">Func&lt;T, ...&gt;</code> as it doesnâ€™t give any indication of what the intention of the code is.)</p>\n<p>The nice thing about delegates is that they will implicitly convert any compatible lambda; so if you need a one-off implementation in test code, you can write it directly in your test method, and not have to create an entirely new class.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-n\">\n<p>Here Iâ€™m going to use strategy in a broad sense, to basically include any behaviour that is injected into a class. Other people might call these collaborators (although Iâ€™d apply that to the implementations of the strategy and not the strategy abstraction itself), or something different.</p>\n<a href=\"#fnref-n\" class=\"footnote-backref\">â†©</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Ignore Null Strategies","date":"January 02, 2000","description":null}}},"pageContext":{"slug":"/ignore-null-strategies/","previous":{"fields":{"slug":"/johannes/"},"frontmatter":{"title":"Johannes"}},"next":{"fields":{"slug":"/managing-multiplicity/"},"frontmatter":{"title":"Managing Multiplicity"}}}},"staticQueryHashes":["240262808","2841359383"]}