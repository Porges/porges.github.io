{"componentChunkName":"component---src-templates-blog-post-js","path":"/ignore-null-strategies/","result":{"data":{"site":{"siteMetadata":{"title":"porg.es"}},"markdownRemark":{"id":"977a2690-ac0d-57ec-a649-6f479385795a","excerpt":"There’s no such thing as a null strategy! Here is a simple refactoring/micro-pattern that can help remove a little complexity from classes that use passed-in…","html":"<blockquote>\n<p>There’s no such thing as a null strategy!</p>\n</blockquote>\n<p>Here is a simple refactoring/micro-pattern that can help remove a little complexity from classes that use passed-in behaviours/strategies/handlers/whatever you want to call them. <sup id=\"fnref-n\"><a href=\"#fn-n\" class=\"footnote-ref\">n</a></sup>\nThe examples given here may seem rather abstract or “enterprisey”, but it’s something that comes up repeatedly when developing software.</p>\n<h3>The problem: Checking strategies for nullness</h3>\n<p>Below is a very simplified example of a consumer (the class <code class=\"language-text\">ProducerExample</code>) of the <code class=\"language-text\">IProducer</code> strategy. The consumer explicitly checks if the strategy is null before invoking it, and if it <em>is</em> null, it produces some default value instead.</p>\n<p>This extra null check gets in the way of what the class is actually doing and introduces an extra code path that is not wanted (or needed).</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=0-producer.cs\"></script>\n<p>(The producer here is deliberately simple—in a real codebase this could take any number of arguments.)</p>\n<p>One situation where this kind of code might appear is when a previously-untested class is being tested for the first time. In this case, dummy values might be inserted in order that <code class=\"language-text\">null</code> can be passed as the strategy at test time and you’ll still get results instead of a <code class=\"language-text\">NullReferenceException</code>. This kind of setup is dangerous, as inadvertently passing <code class=\"language-text\">null</code> in the production code will end up generating these dummy values! 💥</p>\n<p>Here’s a very similar example, using a strategy that doesn’t have a result (which I’ll call a “handler”). This is checked for nullness before it is invoked for its side-effects:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=1-handler.cs\"></script>\n<h3>Solution: Don’t check strategies for nullness!</h3>\n<p>Instead of explicitly checking for nullness, assume that the strategy is not null (you can enforce this in the constructor) and migrate any “default action” into a new implementation of the strategy.</p>\n<p>Then, anywhere you were previously passing in <code class=\"language-text\">null</code>, you can instead pass an instance of your shiny new implementation.</p>\n<p>For the producer example, we can move the default implementation into a new class, and remove the null check:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=2-producer2.cs\"></script>\n<p>(The <code class=\"language-text\">[NotNull]</code> annotation here is something supported by Resharper via the <a href=\"https://www.nuget.org/packages/JetBrains.Annotations\">Resharper.Annotations</a> package.)</p>\n<p>If we need to change the result of the producer depending on what the consumer is, we can use a variation on this, and create an implementation that stores any value we want:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=3-producer2-2.cs\"></script>\n<p>In the “handler” case, we can create a <a href=\"https://en.wikipedia.org/wiki/Null_Object_pattern\">‘null object’ implementation</a> that does nothing, since we don’t need to produce a result:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=4-handler2.cs\"></script>\n<p>With the refactored code, the consuming classes are cleaner (less code, lower cyclomatic complexity), and we have extracted a “default” implementation, which could potentially be used by other consumers.</p>\n<p>At the same time, we have created some useful additional implementations that we can use in unit tests! The “Default” or “Constant” producers are useful when providing canned data to classes that are being tested, and “Null” handlers are useful when ignoring part of the behaviour of a class in order to test other parts.</p>\n<hr>\n<h4>Variation: Function-oriented implementation</h4>\n<p>For single-method interfaces such as those above we can replace them with delegates. This can lead to much cleaner code.</p>\n<p>For producers:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=5-producer-functional.cs\"></script>\n<p>And for handlers:</p>\n<script src=\"https://gist.github.com/Porges/0a079f80ec0b90c4aff9b23ddc3b89c8.js?file=6-handler-functional.cs\"></script>\n<p>I have yet to explore this style in-depth myself, but it seems promising. (I would avoid using pure <code class=\"language-text\">Func&lt;T, ...&gt;</code> as it doesn’t give any indication of what the intention of the code is.)</p>\n<p>The nice thing about delegates is that they will implicitly convert any compatible lambda; so if you need a one-off implementation in test code, you can write it directly in your test method, and not have to create an entirely new class.</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-n\">\n<p>Here I’m going to use strategy in a broad sense, to basically include any behaviour that is injected into a class. Other people might call these collaborators (although I’d apply that to the implementations of the strategy and not the strategy abstraction itself), or something different.</p>\n<a href=\"#fnref-n\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Ignore Null Strategies","date":"January 02, 2000","description":null}}},"pageContext":{"slug":"/ignore-null-strategies/","previous":{"fields":{"slug":"/johannes/"},"frontmatter":{"title":"Johannes"}},"next":{"fields":{"slug":"/managing-multiplicity/"},"frontmatter":{"title":"Managing Multiplicity"}}}},"staticQueryHashes":["240262808","2841359383"]}