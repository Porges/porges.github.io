{"componentChunkName":"component---src-templates-blog-post-js","path":"/managing-multiplicity/","result":{"data":{"site":{"siteMetadata":{"title":"porg.es"}},"markdownRemark":{"id":"bdec4737-06a3-54bc-94f4-fd3392e350a6","excerpt":"Alternate titles: Purging Pluralities, Collapsing Cardinality. Dealing with zero-or-more implementations is a common occurrence when dealing with code that uses‚Ä¶","html":"<p><em>Alternate titles: Purging Pluralities, Collapsing Cardinality.</em></p>\n<p>Dealing with zero-or-more implementations is a common occurrence when dealing with code that uses behaviour injection (<span style=\"font-variant:small-caps; text-transform:lowercase\">AKA</span> the strategy pattern) heavily.</p>\n<p>In this post I‚Äôll demonstrate how to deal with multiplicity for <em>specific types</em> of strategies, in order to remove complexity from the consumer and allow more reuse and flexibility. </p>\n<p>Essentially, we‚Äôll discover how to <em>mechanize</em> the production of <a href=\"http://c2.com/cgi/wiki?CompositePattern\">composites</a>, for types that have some form of <em>monoidal</em> result (which I‚Äôll define at the end).</p>\n<h2>The scenario</h2>\n<p>If we have a class that has some behaviour that is injected, it often makes sense to generalize to allow multiple instances of that behaviour to be injected. We might end up with code that looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IStrategy</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\">Result</span> <span class=\"token function\">DoTheThing</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Input</span> input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Consumer</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">ICollection<span class=\"token punctuation\">&lt;</span>IStrategy<span class=\"token punctuation\">></span></span> _strategies<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">PerformDuties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> strategy <span class=\"token keyword\">in</span> _strategies<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> result <span class=\"token operator\">=</span> strategy<span class=\"token punctuation\">.</span><span class=\"token function\">DoTheThing</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/*...*/</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// do something with result</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This works fine. But there are a few reasons we should avoid this construct.</p>\n<p>The simplest is that we‚Äôll probably end up duplicating this code if we need to use the <code class=\"language-text\">IStrategy</code> in several places ‚Äì once one consumer accepts more than one instance, other consumers are likely to need to as well.</p>\n<p>A deeper problem is that the interpretation of multiple instances‚Äîthat is, <em>how the instances are combined</em>‚Äîis determined by the <em>consumer</em> class and not by the <em>strategy</em>. It would be more coherent for the <code class=\"language-text\">IStrategy</code> interface to decide how to combine multiple instances.</p>\n<p>It turns out that there‚Äôs a simple way to extract this complexity, and allow the strategies to decide how to combine themselves ‚Ä¶ for certain types of strategy. Thankfully these ‚Äòcertain strategies‚Äô are some of the most common ones. In this post I‚Äôll show how this works for:</p>\n<ul>\n<li>strategies that decide <em>whether or not</em> to perform some other action (‚Äúpredicates‚Äù or ‚Äúpolicies‚Äù)</li>\n<li>strategies that are used just for their behaviour and not their result (‚Äúactions‚Äù or ‚Äúhandlers‚Äù, fire-and-forget strategies)</li>\n<li>strategies where you want to collect the results into a list (‚Äúsamplers‚Äù?)</li>\n</ul>\n<p>Let‚Äôs examine how to deal with each of these, and then we‚Äôll see how to generalize this to other types of strategies.</p>\n<h3>Combining policies/predicates</h3>\n<p>A <em>policy</em> decides whether or not to perform an action. Usually when dealing with multiple policies you only want to perform the action if <em>all</em> of them permit it.</p>\n<p>In code, this will look something like this. We have an <code class=\"language-text\">IPolicy</code> interface and a consumer class:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IPolicy</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">UsesPolicy</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">ICollection<span class=\"token punctuation\">&lt;</span>IPolicy<span class=\"token punctuation\">></span></span> _policies<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">PerformDuties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> policy <span class=\"token keyword\">in</span> _policies<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>policy<span class=\"token punctuation\">.</span><span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// we got here, so perform the action</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If any of the policies return <code class=\"language-text\">false</code>, we‚Äôll bail out of the method, but otherwise we will perform the action.</p>\n<p>In order to reduce the complexity of the consumer class, we can create a new implementation of the <code class=\"language-text\">IPolicy</code> interface, which <em>knows how to combine other policies</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CombinedPolicy</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">IPolicy</span></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">NotNull</span></span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IReadOnlyCollection<span class=\"token punctuation\">&lt;</span>IPolicy<span class=\"token punctuation\">></span></span> _policies<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">CombinedPolicy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>IPolicy<span class=\"token punctuation\">></span></span> policies<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        _policies <span class=\"token operator\">=</span> policies<span class=\"token punctuation\">.</span><span class=\"token function\">ToList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">=></span> _policies<span class=\"token punctuation\">.</span><span class=\"token function\">All</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=></span> p<span class=\"token punctuation\">.</span><span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note that <code class=\"language-text\">ShouldPerformAction</code> is (functionally) equivalent to what the consumer class was doing before.</p>\n<p>Given this class, we have a <em>generic way to combine any number of policies into a single policy</em>. Note also that <code class=\"language-text\">CombinedPolicy</code> correctly deals with the case where we have <em>no</em> policies (it will return <code class=\"language-text\">true</code>)‚Äîthis will be important later.</p>\n<p>The end result is that our consumer class will only ever need to deal with <em>one</em> policy at a time!</p>\n<p>So, let‚Äôs simplify it:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">UsesPolicyRevised</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IPolicy</span> _policy<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">PerformDuties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_policy<span class=\"token punctuation\">.</span><span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// perform the action</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Great! Now we only have to deal with one <code class=\"language-text\">IPolicy</code> at a time. The added bonus is that if we have any other classes that use <code class=\"language-text\">IPolicy</code>, they will now <em>automatically</em> be able to deal with <em>any</em> number of policies, and they way they deal with multiple policies will be consistent. üëç</p>\n<h3>Combining fire-and-forget strategies</h3>\n<p>This situation might arise if you want to send a message to several different destinations. Maybe you want to log a message, but also send it to an alerting system.</p>\n<p>Let‚Äôs start with a similar setup to the previous one. We have an <code class=\"language-text\">IDoStuff</code> action interface and a consumer:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IDoStuff</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">InvokesActions</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">ICollection<span class=\"token punctuation\">&lt;</span>IDoStuff<span class=\"token punctuation\">></span></span> _actions<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">PerformDuties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> action <span class=\"token keyword\">in</span> _actions<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            action<span class=\"token punctuation\">.</span><span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here we have a fan-out situation where multiple actions are called on the same value.</p>\n<p>If you‚Äôve been following closely, you‚Äôll know what we have to do next: create a class that does this for us. The important thing is that it is also an instance of <code class=\"language-text\">IDoStuff</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CombinedAction</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">IDoStuff</span></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">NotNull</span></span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IReadOnlyCollection<span class=\"token punctuation\">&lt;</span>IDoStuff<span class=\"token punctuation\">></span></span> _actions<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">CombinedAction</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>IDoStuff<span class=\"token punctuation\">></span></span> actions<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        _actions <span class=\"token operator\">=</span> actions<span class=\"token punctuation\">.</span><span class=\"token function\">ToList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> action <span class=\"token keyword\">in</span> _actions<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            action<span class=\"token punctuation\">.</span><span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now our original class becomes simply:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">InvokesActionsRevised</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IDoStuff</span> _action<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">PerformDuties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        _action<span class=\"token punctuation\">.</span><span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That was pretty easy!</p>\n<p>Something else important has happened here: not only can we give the consumer class multiple actions, but we can customize <em>how multiple actions are performed</em>. </p>\n<p>Let‚Äôs change the interfaces a bit to make it more interesting. Imagine instead that the <code class=\"language-text\">IDoStuff</code> interface was asynchronous:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">IDoStuffAsync</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\">Task</span> <span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">,</span> <span class=\"token class-name\">CancellationToken</span> ct<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now there are two plausible implementations of <code class=\"language-text\">CombinedAction</code>. One will run the actions in sequence, like before (I won‚Äôt show this here), but another possibility is that we want to fire off all the actions at once, in parallel:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">InParallelActions</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">IDoStuffAsync</span></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">NotNull</span></span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IReadOnlyCollection<span class=\"token punctuation\">&lt;</span>IDoStuffAsync<span class=\"token punctuation\">></span></span> _actions<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">InParallelActions</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>IDoStuffAsync<span class=\"token punctuation\">></span></span> actions<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        _actions <span class=\"token operator\">=</span> actions<span class=\"token punctuation\">.</span><span class=\"token function\">ToList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">Task</span> <span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">,</span> <span class=\"token class-name\">CancellationToken</span> ct<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">=></span> Task<span class=\"token punctuation\">.</span><span class=\"token function\">WhenAll</span><span class=\"token punctuation\">(</span>_actions<span class=\"token punctuation\">.</span><span class=\"token function\">Select</span><span class=\"token punctuation\">(</span>action <span class=\"token operator\">=></span> action<span class=\"token punctuation\">.</span><span class=\"token function\">DoStuff</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> ct<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This gives us more flexibility, and we can make decisions about how the actions are to be performed (in sequence or in parallel) <em>without changing the consuming class</em>.</p>\n<h3>Collecting results into a list</h3>\n<p>This situation might arise if you have a range of ‚Äòsamplers‚Äô that you want to run on some object. Perhaps you want to read several different indicators of ‚Äúhealth‚Äù from a computer‚Äîperformance counters, IO stats, memory usage and so on‚Äîand then collect these all these results into a list to store for later retrieval.</p>\n<p>Each individual collector would be a separate class, so that you can develop &#x26; test them in isolation.</p>\n<p>The initial setup should be familiar by now. We have an interface <code class=\"language-text\">ICollectInformation</code> and a consumer class:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Datum</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">string</span></span> Key <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">double</span></span> Value <span class=\"token punctuation\">{</span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ICollectInformation</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\">Datum</span> <span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CollectsInformation</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">ICollection<span class=\"token punctuation\">&lt;</span>ICollectInformation<span class=\"token punctuation\">></span></span> _collecters<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">DoCollection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">List<span class=\"token punctuation\">&lt;</span>Datum<span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">foreach</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">var</span></span> collector <span class=\"token keyword\">in</span> _collecters<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            data<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>collector<span class=\"token punctuation\">.</span><span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        \n        <span class=\"token comment\">// do something with data</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>At this point, we want to be able to create an instance which will collect items into a list for us. However, we can‚Äôt return a list from <code class=\"language-text\">ICollectInformation</code>‚Äîit can only return a single <code class=\"language-text\">Datum</code>. So, let‚Äôs alter this interface (it‚Äôs our code, after all), and change it to return any number of items:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ICollectInformation</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token return-type class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>Datum<span class=\"token punctuation\">></span></span> <span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now we can write the implementation of <code class=\"language-text\">ICollectInformation</code> that we want:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">AggregateCollector</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">ICollectInformation</span></span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token attribute\"><span class=\"token class-name\">NotNull</span></span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">IReadOnlyCollection<span class=\"token punctuation\">&lt;</span>ICollectInformation<span class=\"token punctuation\">></span></span> _collectors<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">AggregateCollector</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>ICollectInformation<span class=\"token punctuation\">></span></span> collectors<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        _collectors <span class=\"token operator\">=</span> collectors<span class=\"token punctuation\">.</span><span class=\"token function\">ToList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\">IEnumerable<span class=\"token punctuation\">&lt;</span>Datum<span class=\"token punctuation\">></span></span> <span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">=></span> <span class=\"token keyword\">from</span> collector <span class=\"token keyword\">in</span> _collectors\n           <span class=\"token keyword\">from</span> datum <span class=\"token keyword\">in</span> collector<span class=\"token punctuation\">.</span><span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n           <span class=\"token keyword\">select</span> datum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And our consumer class again only has to deal with a single instance:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CollectsInformationRevised</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">ICollectInformation</span> _collecter<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Collect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> data <span class=\"token operator\">=</span> _collecter<span class=\"token punctuation\">.</span><span class=\"token function\">CollectInformation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ToList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// do something with data</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once again, complexity averted!</p>\n<h2>The general case</h2>\n<p>So, what‚Äôs the magic ingredient here that allows us to combine these types of strategies? The key is that the result type of each can be treated as a <em>monoid</em>.</p>\n<p>A type is a <strong>monoid</strong> (or is <strong>monoidal</strong>), if it satisfies three conditions:</p>\n<blockquote>\n<p>1. You can combine two (or more) instances of it to form something that has the same type. </p>\n</blockquote>\n<p>This allows us to ‚Äúsquash‚Äù multiple return values together, so we can reduce many strategies to one strategy.</p>\n<blockquote>\n<p>2. The combining function (call it <code class=\"language-text\">#</code>) must be associative so that it doesn‚Äôt matter ‚Äúwhich way‚Äù you group the instances when combining‚Äî<code class=\"language-text\">x # (y # z)</code> should be the same as <code class=\"language-text\">(x # y) # z</code>. (But order can matter, <code class=\"language-text\">x # y</code> doesn‚Äôt have to be the same as <code class=\"language-text\">y # x</code>.)</p>\n</blockquote>\n<p>Although it wasn‚Äôt used above, this means we can nest strategies arbitrarily using our combiners, and it won‚Äôt affect the result.</p>\n<blockquote>\n<p>3. There is an instance (called the ‚Äúidentity‚Äù) that can be combined with any other instance without changing the result. </p>\n</blockquote>\n<p>This is important as it allows us to produce a result in the case that we have zero strategies, and gives us sane results in other cases.</p>\n<p>Here‚Äôs how the previous examples match up to the monoid concept:</p>\n<p>In the first example (combining policies), we were (1.) combining multiple booleans using <code class=\"language-text\">&amp;&amp;</code> under the covers to get back another boolean. For condition (2.), it doesn‚Äôt matter if you write <code class=\"language-text\">a &amp;&amp; (b &amp;&amp; c)</code> or <code class=\"language-text\">(a &amp;&amp; b) &amp;&amp; c</code>, as it will give you the same answer, and (3.) if you combine <code class=\"language-text\">true</code> with any boolean using <code class=\"language-text\">&amp;&amp;</code>, you get back the original boolean, so <code class=\"language-text\">true</code> is the identity for <code class=\"language-text\">&amp;&amp;</code>.</p>\n<p>For the second example (combining actions) we were essentially using <code class=\"language-text\">void</code> as a monoidal type. It‚Äôs not very interesting since combining two <code class=\"language-text\">void</code>s (via sequencing) just gives you another <code class=\"language-text\">void</code>‚Äîso the third condition is trivially satisfied.</p>\n<p>For the third example (combining samplers), we were using <code class=\"language-text\">IEnumerable</code>. In this case, the combining operation is concatenation, and the identity is the empty enumerable. Since a monoid combining operation must produce something of the same type as its inputs, and we can‚Äôt combine two <code class=\"language-text\">Datum</code>s to make another <code class=\"language-text\">Datum</code>, we had to change the result type of the <code class=\"language-text\">ICollectInformation</code> interface to return an enumerable before we could create the combining class.</p>\n<p>I tried to pick three monoids that are useful for dealing with strategies here. Numbers can also be monoids (<a href=\"https://en.wikipedia.org/wiki/Monoid#Examples\">the sum or product monoids, or max or min monoids</a>), but I don‚Äôt think they‚Äôre as useful in this particular situation.</p>\n<p>So, to summarize: Once you have discovered that the result type of a strategy can be treated as a monoid, then you can apply the above techniques to result in simpler, cleaner code:</p>\n<ol>\n<li>Identify what the combining operation for a particular strategy type is.</li>\n<li>Extract a class that performs that operation (and is an instance of the same interface).</li>\n<li>Remove the complexities of the combining operation from the consuming classes, so that they only need to consider a single instance.</li>\n</ol>\n<h4>Extra: Making combining more palatable (C#-specific)</h4>\n<p>If possible, you could also switch out the interface for an abstract base class. This allows us to define operators on the class, so we can easily combine multiple instances without having to use the ‚Äòcombiner‚Äô type explicitly. Indeed, we can hide the combiner type internally:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PolicyType</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> PolicyType <span class=\"token keyword\">operator</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PolicyType</span> first<span class=\"token punctuation\">,</span> <span class=\"token class-name\">PolicyType</span> second<span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">CombinedPolicy</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// this could be much cleaner if C# ever gets F#-style object expressions:</span>\n    <span class=\"token comment\">// https://github.com/dotnet/roslyn/issues/13#issuecomment-195161037</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CombinedPolicy</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">PolicyType</span></span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">PolicyType</span> _first<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">readonly</span> <span class=\"token class-name\">PolicyType</span> _second<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">CombinedPolicy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PolicyType</span> first<span class=\"token punctuation\">,</span> <span class=\"token class-name\">PolicyType</span> second<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{</span>\n            _first <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n            _second <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">override</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool</span></span> <span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Item</span> item<span class=\"token punctuation\">)</span>\n            <span class=\"token operator\">=></span> _first<span class=\"token punctuation\">.</span><span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> _second<span class=\"token punctuation\">.</span><span class=\"token function\">ShouldPerformAction</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then we can simply combine policies via <code class=\"language-text\">p1 &amp; p2</code>. Note that this relies on the associativity of the monoid to work well!</p>\n<hr>\n<h4>A final note</h4>\n<p>The deeper reason that this all works is not only that the <em>result</em> type is monoidal, but that <code class=\"language-text\">Func&lt;TArg, TResult&gt;</code> is <em>itself</em> a monoid, if its result is a monoidal type. This allows us to combine multiple instances of <code class=\"language-text\">Func&lt;TArg, TResult&gt;</code>. See if you can figure out what the combining function is for it! I‚Äôll also explore this more in a future post.</p>","frontmatter":{"title":"Managing Multiplicity","date":"January 03, 2000","description":null}}},"pageContext":{"slug":"/managing-multiplicity/","previous":{"fields":{"slug":"/ignore-null-strategies/"},"frontmatter":{"title":"Ignore Null Strategies"}},"next":{"fields":{"slug":"/model-based-testing/"},"frontmatter":{"title":"(Poor man‚Äôs) model-based testing with F# & FsCheck"}}}},"staticQueryHashes":["240262808","2841359383"]}